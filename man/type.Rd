% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/type.R
\name{type}
\alias{htype}
\alias{htype<-}
\alias{ip}
\alias{ip<-}
\alias{nhargs}
\alias{op}
\alias{op<-}
\alias{parse_type}
\alias{type}
\alias{type_str}
\title{Access, set, and print function types}
\usage{
type_str(f)

parse_type(x, role = "pipe")

htype(f)

ip(f)

op(f)

htype(f) <- value

ip(f) <- value

op(f) <- value

nhargs(f)
}
\arguments{
\item{f}{any function}

\item{x}{type string}

\item{role}{['well', 'pipe', 'sink']}

\item{value}{character string}
}
\description{
Access, set, and print function types
}
\section{Details}{


Functional types are based on Haskell types. For example, a function that sums
two integers, might have the type, 'Int -> Int -> Int'. The first 2 `Int`s are
the input integers, that last is the output. Every hnode has a type attribute,
which contains $n+1$ elements in a character vector, where $n$ is the number of
inputs.

*htype* prints the type character vector, *ip* prints the input types (all
but the last elements), and *op* prints the output type (the last element of
the type vector). *nhtypes* counts the number of inputs. *type_str* converts
from a character vector to a Haskell syntax function definition.

*parse_type* attempts to extract a type (as a character vector) from
whatever input it is given. Legal input is 1) Haskell style type (e.g. 'a ->
b') or 2) a character vector or 3) an object with a non-NULL htype
attribute. Anything else will result in an error.
}

